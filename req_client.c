/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include "req.h"
#include "proj.h"

void
ppc_request(char *host, char *request) {
	CLIENT *clnt;
	t_string  *result_1;
	t_string  req_receipt_1_arg;
	t_string  *result_2;
	t_pair  req_1_arg;
	char status[MAX_TOKEN];
	char serverAuthTokenString[MAX_TOKEN];
	char serverDecryptedAuthTokenString[MAX_TOKEN];
	char clientPrivateKey[MAX_LINE];
	char serverPublicKey[MAX_LINE];
	char labelString[MAX_TOKEN];
	char bolt11[MAX_LINE];
	char proofOfPayment[MAX_LINE];
	t_auth_code serverAuthToken;

#ifndef	DEBUG
	clnt = clnt_create (host, REQ_PROG, REQ_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	req_receipt_1_arg.data = request;
	printf("[1]::RPC: Client requesting server to provide invoice for PPC call: \n%s\n",
		request);
	result_1 = req_receipt_1(&req_receipt_1_arg, clnt);
	if (result_1 == (t_string *) NULL) {
		clnt_perror (clnt, "call failed");
		exit (1);
	}
	else if (!strcmp(getToken(result_1->data, 
			TOKEN_RETURN_ID_STATUS, status), 
			INVOICE_FAIL_CODE_INVALID_SERVICE_REQ)) {
		printf("Service not supported by server\n");
		exit (1);
	}
	else if (strcmp(getToken(result_1->data, 
			TOKEN_RETURN_ID_STATUS, status), 
			INVOICE_SUCCESS_CODE)) {
		printf("Server failed to generate invoice\n");
		exit (1);
	}
	else
	{
		printf("[5]::RPC: Client received bolt11_invoice from server\n");
		printf("Client received: %s\n", result_1->data);

		// check if received initial auth token from the server
		if (getToken(result_1->data, TOKEN_RETURN_ID_AUTH, 
				serverAuthTokenString) == NULL) {
			printf("Missing authorization token received from server\n");
			exit (1);
		}

		// load private RSA key
                if (exec_command("cat ~/.ppc/id_ppc" , clientPrivateKey) ||
				strlen(clientPrivateKey) == 0) {
			printf("Could not find the client private key: ~/PPC/id_ppc\n");
			exit (1);
		}

		// decrypt auth token
		cl_string_to_auth_code(cl_RSA_decrypt(serverAuthTokenString,
			serverDecryptedAuthTokenString, clientPrivateKey), 
			&serverAuthToken);

		// check token format
		if (!cl_is_server_auth_code_proper_format(&serverAuthToken)) {
			printf("Invalid format authorization token received from server\n");
			exit (1);
		}

		// get label identifying this transaction
		if (getToken(result_1->data, TOKEN_RETURN_ID_LABEL, 
						labelString) == NULL) {
			printf("Missing label from server\n");
			exit (1);
		}

		// get server's public RSA key
		if (getToken(result_1->data, TOKEN_RETURN_ID_KEY, 
						serverPublicKey) == NULL) {
			printf("Missing RSA public key from server\n");
			exit (1);
		}

		// get bolt11
		if (getToken(result_1->data, TOKEN_RETURN_ID_BOLT11, 
						bolt11) == NULL) {
			printf("Missing bolt11 string from server\n");
			exit (1);
		}

		// pay bolt11
		if (cl_pay_invoice(bolt11, proofOfPayment) == FAILED) {
			printf("Payment failed for blot11: %s\n", bolt11);
			exit (1);
		}
	}
// ###MKG client must parse return from 1st RPC and pass it as authorization in 2nd RPC)
//	req_1_arg.authorizationLabeldInvoice = invoice->data;  ###MKG Fix THis */
//	req_1_arg.data = request;

//	printf("[7]::RPC: Client requesting service from server\n");
//	result_2 = req_1(&req_1_arg, clnt);
//	if (result_2 == (t_string *) NULL) {
//		clnt_perror (clnt, "call failed");
//	}
//	else
//	{
//		printf("[12]::RPC: Client received result of query: %s\n", result_2->data);
//	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */

	exit(0);
}

int
isQuantityValid(char *quantity) {
	int q = atoi(quantity);
	if (q > 0 && q < MAX_VALID_QUANTITY)
		return TRUE;
	else
		return FALSE;
}

int
main (int argc, char *argv[])
{	
	char reqString[MAX_LINE];
	int quantity = 0;
	reqString[0] = '\0';
	char *clientRSAPublicKey;

	// allocate memory to hold client RSA public key
	clientRSAPublicKey = (char *) calloc(MAX_LINE, sizeof(char));
	if (clientRSAPublicKey == NULL) {
		printf("Out of memory...");
		exit(1);
	}

	if (argc != 4) {
		printf ("usage: %s server_ip service_type quantity\n", argv[0]);
		exit (1);
	}

	// check to make sure quantity is valid
	if (!isQuantityValid(argv[3]))
		printf("usage: invalid quantity specified: %s\n", argv[3]);

	printf("Client initialting Pay Per Call (PPC) request to %s for %d %s.\n",
		argv[1], atoi(argv[3]), argv[2]);

	strcpy(reqString, argv[2]);
	addToken(reqString, argv[3]);
        if (exec_command("cat ~/.ppc/id_ppc.pub" , clientRSAPublicKey)
				|| strlen(clientRSAPublicKey) == 0) {
		printf("Could not find the client public key (PEM file): ~/PPC/id_ppc.pub\n");
		exit(1);
	}

	addToken(reqString, clientRSAPublicKey);
	free(clientRSAPublicKey);

	ppc_request (argv[1], reqString);
}
