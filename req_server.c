#include "proj.h"

static char empty[2];
static t_string emptyResult;

bool_t
is_service_type_valid(char *service_type) { 
	// List valid service types
	if (!strcmp(service_type, SERVICE_TYPE_1))  // stock quotes
		return TRUE;
	return FALSE;
}

// Use a simple fee structure for DEMO code
float 
calc_fee(char *serviceType, int quantity) {
	float fee = CALL_FEE * (float) sqrt((double) quantity);

	// Make sure a minimum fee is imposed, so lightning 
	// payment can find a route
	if (fee < MIN_BUNDLE_FEE)
		fee = MIN_BUNDLE_FEE;

	return fee;       
}

char *
cl_parse_invoice(t_ctl_block *blk) {
	json_error_t error;
	json_t *bolt11;
	json_t *root = json_loads(blk->invoice, 0, &error);
	RSA *clientKey;
	RSA *serverKeypair;
	char *base64EncodedEncryptedString;
	char b11[MAX_LINE];
	unsigned char line[MAX_LINE];
	unsigned char serverPrivateKey[MAX_LINE];
	unsigned char encryptedAuth[MAX_TOKEN];
	unsigned char hexString[MAX_TOKEN];
	unsigned char encryptMsg[MAX_LINE];
	unsigned char clientMsg[MAX_BUF];
	size_t encrypt_len;
	unsigned char *base64Sig;
	size_t sigLength;

	*b11 = '\0';
        if (!root) {
		printf("Error loading JSON invoice: %s\n", blk->invoice);
		cl_deauthorize(blk);
	}
	else {
	        bolt11 = json_object_get((json_t *) root, "bolt11");
		if (bolt11 == NULL) {
			cl_deauthorize(blk);
		}
		else {
			strcat(b11, json_string_value(bolt11));
			strcpy(blk->bolt11, b11);
		}
	}

	json_decref(root);

	clientKey = RSA_new();
	pemPublicKeyStringToRsa(clientKey, blk->clientPublicKey);

	// Construct return parameters for client
	if (cl_is_authorized(blk)) {
		clientMsg[0]='\0';
		strcpy(clientMsg, INVOICE_SUCCESS_CODE);
		addToken(clientMsg, 
				cl_session_key_to_string(blk->sessionKey, 
				hexString));
		addToken(clientMsg, cl_label_to_string(blk->label, hexString));
		addToken(clientMsg, b11);
		printf("Cleartext content to client for label %ld:\n%s\n", 
				blk->label, clientMsg);

		// Encrypt server's response before sending to client
		if((encrypt_len = RSA_public_encrypt(strlen(clientMsg) + 1, 
					clientMsg, encryptMsg, clientKey, 
					RSA_PKCS1_OAEP_PADDING)) == -1) {
			printf("Error encrypting message: FAILED!!!!\n");
			RSA_free(clientKey);
			return INVOICE_FAIL_CODE;
		}
		// There are three tokens in message sent to server:
		//	1) base64 encoded encrypted bundle of:
		//         returnCode+sessionKey+bolt11
		//	2) client's RSA public key (unencrypted)
		//	3) server's signature
		Base64Encode(encryptMsg, encrypt_len, 
				&base64EncodedEncryptedString);
		strcpy(clientMsg, base64EncodedEncryptedString);
		addToken(clientMsg, blk->clientPublicKey);

		// Sign reply to client
		serverKeypair = getRSAKey();

		if ((base64Sig = RSASignBase64(serverKeypair, clientMsg, 
					strlen(clientMsg))) == NULL) {
			printf("Failed to sign\n");
			RSA_free(clientKey);
			return INVOICE_FAIL_CODE;
		}

		addToken(clientMsg, base64Sig);

		strcpy(blk->statusSessionKeyClientPublicKeyBolt11, clientMsg);

        	printf("[4]::RPC: Sending bolt11_invoice to "
				"client for label %ld\n", 
				blk->label);

		RSA_free(clientKey);
		return blk->statusSessionKeyClientPublicKeyBolt11;
	}
	else {
		printf("Could not parse invoice.\n");
		RSA_free(clientKey);
		return INVOICE_FAIL_CODE;
	}
}

char *
cl_make_invoice(t_ctl_block *blk, int msatoshi, char *description) {
	char cmd_string[MAX_LINE];
	char *parsedInvoice;

	blk->invoice[0] = '\0';

	printf("[2]::RPC: Received client request to generate invoice\n");
	(void) sprintf(cmd_string, "lightning-cli invoice %d %ld %s", 
			msatoshi, blk->label, description); 
	printf("Generating invoice of %d msatoshi for label %ld for %s\n",
			msatoshi, blk->label, description);
	printf("[3]:Lightning_API: %s\n", cmd_string);

	if (exec_command(cmd_string, blk->invoice)) {
		printf("exec command failed to generate invoice\n");
		return INVOICE_FAIL_CODE;
	}

	printf("Full invoice is %s\n", blk->invoice);

	parsedInvoice = cl_parse_invoice(blk);

	return parsedInvoice;
}

// This function is invoked from client side (via RPC) to generate bolt11 
// invoice. It is also used to piggyback exchange security and other 
// parameters, such as:
// 1) Authorization Code: Generated by client and is used subsequently 
//    by client invoking req_1_svc() to validate that request for service
//    are authorized (came from the client). Client notifies the Server of
//    the Authorization Code it generated using this exchange here.  
//    The Authorization Code is used to generate a set of one time codes 
//    that are different on each invocation of req_1_svc(); this is to avoid
//    "replay" attack.
// 2) Session Code: Used to encrypt service response to req_1_svc() 
//    using symmetric encryption. The Session Code is generated by Server 
//    and notified to the Client using the reply to this function via RPC.
// 3) Label: This identifies this particular transaction to the lightning 
//    network.
// 4) Client RSA Public Key: Client is identified using its public key that
//    appears here. Bolt11 invoice is bounded to client RSA Public Key. Replies
//    to client are encrypted using client's public key. The client (i.e., the
//    entity that has the private keyassociated with this public key) is 
//    the only entity which can subsequently request service by invoking 
//    req_1_svc() via RPC.
// 5) S erver's Signature: Server signs its response to client using server's
//    private key. Client is configured (manually) with server's public key, 
//    and can validate the server's signature using the server's public key to 
//    make sure response came from the intended server. This is required to 
//    avoid "man-in-the-middle" attack.
t_string *
req_receipt_1_svc(t_string *argp, struct svc_req *rqstp)
{
	static t_string result;
	t_ctl_block *blk;
	char quantity[MAX_SMALL_TOKEN];
	char serviceType[MAX_SMALL_TOKEN];
	char description[MAX_TOKEN] = {'\0'};
	char authCodeString[MAX_SMALL_TOKEN];
	float fee;
	RSA *serverKeypair;
	t_auth_code *authCode;
	char clearString[MAX_BUF];
	unsigned char *buf;
	char *base64EncodedEncryptedString;
	char encyptedRequest[MAX_BUF];
	char token[MAX_BUF];
	size_t encrypt_len;

	serverKeypair = getRSAKey();

	blk = cache_add_blk();
	if (blk == NULL) {
		strcpy(empty, INVOICE_FAIL_CODE_ALLOC);
		emptyResult.data = empty; 
		return &emptyResult;
	}
	else {
		// Decrypt client's request
		getToken(argp->data, TOKEN_ID_ENC_BUNDLE, token);
		Base64Decode(token, &buf, &encrypt_len);
		if (RSA_private_decrypt(encrypt_len, buf, clearString,
                       			serverKeypair, 
					RSA_PKCS1_OAEP_PADDING) == -1) {
  			printf("Error decrypting message: FAILED!!!\n");
			strcpy(empty, INVOICE_FAIL_CODE_DECRYPT);
			emptyResult.data = empty; 
			return &emptyResult;	
		} else {
			addToken(clearString, getToken(argp->data, 
						TOKEN_ID_ENC_PUBLIC_KEY, 
						token));
   			printf("Decrypted message from client:\n%s\n", 
						clearString);
		}
		
		blk->label = make_rand_label();
		strcpy(description, getToken(clearString, 
					TOKEN_ID_SERVICE_TYPE, serviceType));
		if (!is_service_type_valid(serviceType)) {
			strcpy(empty, INVOICE_FAIL_CODE_INVALID_SERVICE_REQ);
			emptyResult.data = empty; 
			return &emptyResult;			
		}

		getToken(clearString, TOKEN_ID_QUANTITY, quantity);
		if (!isQuantityValid(quantity)) {
			strcpy(empty, INVOICE_FAIL_CODE_QUANTITY);
			emptyResult.data = empty; 
			return &emptyResult;	
		}
		addToken(description, quantity);

		// Get auth code from client
		getToken(clearString, TOKEN_ID_AUTH_CODE, authCodeString);
		cl_string_to_auth_code(authCodeString, &(blk->authCode));

		if (!cl_is_client_auth_code_proper_format(&(blk->authCode))) {
			strcpy(empty, INVOICE_FAIL_CODE_AUTH);
			emptyResult.data = empty; 
			return &emptyResult;	
		}
		cl_authorize(blk);
		
		// Get client's public key
		getToken(clearString, TOKEN_ID_PUBLIC_KEY, 
					blk->clientPublicKey);

		// Generate invoice
		fee = calc_fee(serviceType, atoi(quantity));
		(blk->receiptResult).data = cl_make_invoice(blk, fee,
							    description);

		return &(blk->receiptResult);
	}
}

// This function is invoked by the client to receive the requested service.
// Upon each invocation of this function a different one-time authorization
// code is used by the client. These can be validated by the server to make
// sure requests are made by the authorized client. The server would only
// provide up to the "quantity" of service that was requested and paid 
// for. 
t_string *
req_1_svc(t_pair *argp, struct svc_req *rqstp)
{
	t_ctl_block *blk;
	static t_string  result;
	static char result_text[20] = "Result_String";

	printf("[8]::RPC: Server receives request for service\n");
	// ###MKG pass in label as arg (after pool implementation)
        blk = find_block_from_label("argp->authorization");  
	if (blk->state != STATE_PAYMENT_VERIFIED) {
		blk->state = STATE_WAIT_FOR_PAYMENT;
		if (cl_wait_for_payment(blk->label) == SUCCESS) {
			blk->state = STATE_PAYMENT_VERIFIED;
		}
		else {
			blk->state = STATE_PAYMENT_FAILED;
			strcpy(empty, INVOICE_FAIL_CODE);
			emptyResult.data = empty; 
			return &emptyResult;			
		}
	}

	result.data = result_text;
	printf("[11]::RPC: Server sent result of query: %s\n", result_text);

	return &result;
}
