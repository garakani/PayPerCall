#include "proj.h"

static char empty[MAX_SMALL_TOKEN];
static t_string emptyResult;

bool_t
isServiceTypeValid(char *service_type) { 
	// List valid service types
	if (!strcmp(service_type, SERVICE_TYPE_1))  // stock quotes
		return TRUE;
	return FALSE;
}

// Use a simple fee structure for DEMO code
float 
calcFee(char *serviceType, int quantity) {
	float fee = CALL_FEE * (float) sqrt((double) quantity);

	// Make sure a minimum fee is imposed, so lightning 
	// payment can find a route
	if (fee < MIN_BUNDLE_FEE)
		fee = MIN_BUNDLE_FEE;

	return fee;       
}

char *
makeInvoice(t_ctl_block *blk, int msatoshi, char *description) {
	json_error_t error;
	json_t *bolt11;
	json_t *root;
	RSA *clientKey;
	RSA *serverKeypair;
	char *base64EncodedEncryptedString;
	char b11[MAX_LINE];
	unsigned char line[MAX_LINE];
	unsigned char serverPrivateKey[MAX_LINE];
	unsigned char encryptedAuth[MAX_TOKEN];
	unsigned char hexString[MAX_TOKEN];
	unsigned char encryptMsg[MAX_LINE];
	unsigned char clientMsg[MAX_BUF];
	size_t encLength;
	unsigned char *base64Sig;
	size_t sigLength;

	if (getInvoice(blk, msatoshi, description) == INVOICE_FAIL_CODE)
		return INVOICE_FAIL_CODE;

	root = json_loads(blk->invoice, 0, &error);

	*b11 = '\0';
        if (!root) {
		printf("Error loading JSON invoice: %s\n", blk->invoice);
		deauthorize(blk);
	}
	else {
	        bolt11 = json_object_get((json_t *) root, "bolt11");
		if (bolt11 == NULL) {
			deauthorize(blk);
		}
		else {
			strcat(b11, json_string_value(bolt11));
			strcpy(blk->bolt11, b11);
		}
	}

	json_decref(root);

	clientKey = RSA_new();
	pemPublicKeyStringToRsa(clientKey, blk->clientPublicKey);

	// Construct return parameters for client
	if (isAuthorized(blk)) {
		clientMsg[0]='\0';
		strcpy(clientMsg, INVOICE_SUCCESS_CODE);
		addToken(clientMsg, 
				sessionKeyToString(blk->sessionKey, 
				hexString));
		addToken(clientMsg, labelToString(blk->label, hexString));
		addToken(clientMsg, b11);
		printf("Cleartext content to client for label %ld:\n%s\n", 
				blk->label, clientMsg);

		// Encrypt server's response before sending to client
		if((encLength = RSA_public_encrypt(strlen(clientMsg) + 1, 
					clientMsg, encryptMsg, clientKey, 
					RSA_PKCS1_OAEP_PADDING)) == -1) {
			printf("Error encrypting message: FAILED!!!!\n");
			RSA_free(clientKey);
			return INVOICE_FAIL_CODE;
		}
		// There are three tokens in message sent to server:
		//	1) base64 encoded encrypted bundle of:
		//         returnCode+sessionKey+bolt11
		//	2) client's RSA public key (unencrypted)
		//	3) server's signature
		Base64Encode(encryptMsg, encLength, 
				&base64EncodedEncryptedString);
		strcpy(clientMsg, base64EncodedEncryptedString);
		addToken(clientMsg, blk->clientPublicKey);

		// Sign reply to client
		serverKeypair = getRSAKey();

		if ((base64Sig = RSASignBase64(serverKeypair, clientMsg, 
					strlen(clientMsg))) == NULL) {
			printf("Failed to sign\n");
			RSA_free(clientKey);
			return INVOICE_FAIL_CODE;
		}

		addToken(clientMsg, base64Sig);

		strcpy(blk->statusSessionKeyClientPublicKeyBolt11, clientMsg);

        	printf("[4]::RPC: Sending bolt11_invoice to "
				"client for label %ld\n", 
				blk->label);

		RSA_free(clientKey);
		return blk->statusSessionKeyClientPublicKeyBolt11;
	}
	else {
		printf("Could not parse invoice.\n");
		RSA_free(clientKey);
		return INVOICE_FAIL_CODE;
	}
}

// This function is invoked from client side (via RPC) to generate bolt11 
// invoice. It is also used to piggyback exchange security and other 
// parameters, such as:
// 1) Authorization Code: Generated by client and is used subsequently 
//    by client invoking req_1_svc() to validate that request for service
//    are authorized (came from the client). Client notifies the Server of
//    the Authorization Code it generated using this exchange here.  
//    The Authorization Code is used to generate a set of one time codes 
//    that are different on each invocation of req_1_svc(); this is to avoid
//    "replay" attack.
// 2) Session Code: Used to encrypt service response to req_1_svc() 
//    using symmetric encryption. The Session Code is generated by Server 
//    and notified to the Client using the reply to this function via RPC.
// 3) Label: This identifies this particular transaction to the lightning 
//    network.
// 4) Client RSA Public Key: Client is identified using its public key that
//    appears here. Bolt11 invoice is bounded to client RSA Public Key. Replies
//    to client are encrypted using client's public key. The client (i.e., the
//    entity that has the private keyassociated with this public key) is 
//    the only entity which can subsequently request service by invoking 
//    req_1_svc() via RPC.
// 5) S erver's Signature: Server signs its response to client using server's
//    private key. Client is configured (manually) with server's public key, 
//    and can validate the server's signature using the server's public key to 
//    make sure response came from the intended server. This is required to 
//    avoid "man-in-the-middle" attack.
t_string *
req_receipt_1_svc(t_string *argp, struct svc_req *rqstp)
{
	int error;
	pthread_t threadId;
	static t_string result;
	t_ctl_block *blk;
	char quantity[MAX_SMALL_TOKEN];
	char serviceType[MAX_SMALL_TOKEN];
	char description[MAX_TOKEN] = {'\0'};
	char authCodeString[MAX_SMALL_TOKEN];
	float fee;
	RSA *serverKeypair;
	t_auth_code *authCode;
	char clearString[MAX_BUF];
	unsigned char *buf;
	char *base64EncodedEncryptedString;
	char encyptedRequest[MAX_BUF];
	char token[MAX_BUF];
	size_t encLength;

	serverKeypair = getRSAKey();

	uint64_t label = makeRandLabel();
	blk = cacheAddBlk(label);
	if (blk == NULL) {
		strcpy(empty, INVOICE_FAIL_CODE_ALLOC);
		emptyResult.data = empty; 
		return &emptyResult;
	}
	else {
		// Decrypt client's request
		getToken(argp->data, TOKEN_ID_ENC_BUNDLE, token);
		Base64Decode(token, &buf, &encLength);
		if (RSA_private_decrypt(encLength, buf, clearString,
                       			serverKeypair, 
					RSA_PKCS1_OAEP_PADDING) == -1) {
  			printf("Error decrypting message: FAILED!!!\n");
			strcpy(empty, INVOICE_FAIL_CODE_DECRYPT);
			emptyResult.data = empty; 
			return &emptyResult;	
		} else {
			addToken(clearString, getToken(argp->data, 
						TOKEN_ID_ENC_PUBLIC_KEY, 
						token));
   			printf("Decrypted message from client:\n%s\n", 
						clearString);
		}
		
		blk->label = label;
		strcpy(description, getToken(clearString, 
					TOKEN_ID_SERVICE_TYPE, serviceType));
		if (!isServiceTypeValid(serviceType)) {
			strcpy(empty, INVOICE_FAIL_CODE_INVALID_SERVICE_REQ);
			emptyResult.data = empty; 
			return &emptyResult;			
		}

		getToken(clearString, TOKEN_ID_QUANTITY, quantity);
		if (!isQuantityValid(quantity)) {
			strcpy(empty, INVOICE_FAIL_CODE_QUANTITY);
			emptyResult.data = empty; 
			return &emptyResult;	
		}
		addToken(description, quantity);

		// Get auth code from client
		getToken(clearString, TOKEN_ID_AUTH_CODE, authCodeString);
		stringToAuthCode(authCodeString, &(blk->authCode));

		if (!isClientAuthCodeProperFormat(&(blk->authCode))) {
			strcpy(empty, INVOICE_FAIL_CODE_AUTH);
			emptyResult.data = empty; 
			return &emptyResult;	
		}
		authorize(blk);
		
		// Get client's public key
		getToken(clearString, TOKEN_ID_PUBLIC_KEY, 
					blk->clientPublicKey);

		// Generate invoice
		fee = calcFee(serviceType, atoi(quantity));
		(blk->receiptResult).data = makeInvoice(blk, fee,
							    description);

		blk->minSeqAllowed = 1;
		blk->maxSeqAllowed = atoi(quantity);
		blk->state = STATE_WAIT_FOR_PAYMENT;
        	error = pthread_create(&threadId, NULL, waitForPayment, 
					(void *) blk);
       	 	if (!error)
            		printf("\nThread creation successful\n");
		else
			printf("\nThread creation failed!\n"); 

		return &(blk->receiptResult);
	}
}

// This function is invoked by the client to receive the requested service.
// Upon each invocation of this function a different one-time authorization
// code is used by the client. These can be validated by the server to make
// sure requests are made by the authorized client. The server would only
// provide up to the "quantity" of service that was requested and paid 
// for. 
t_string *
req_1_svc(t_string *argp, struct svc_req *rqstp)
{
	int error;
	RSA *serverKeypair;
	pthread_t threadId;
	t_ctl_block *blk;
	static t_string  result;
	char token[MAX_TOKEN];
	char param[MAX_TOKEN];
	unsigned char *buf;
	size_t encLength;
	char clearString[MAX_BUF];
	t_auth_code authCode;
	int sequenceNum;

	static char result_text[20] = "Result_String";

	printf("\n[8]::RPC: Server receives request for service\n");

	serverKeypair = getRSAKey();

	// Decrypt client's service request
	getToken(argp->data, TOKEN_ID_ENC_BUNDLE, token);
	Base64Decode(token, &buf, &encLength);
	if (RSA_private_decrypt(encLength, buf, clearString,
                       			serverKeypair, 
					RSA_PKCS1_OAEP_PADDING) == -1) {
  		printf("Error decrypting message: FAILED!!!\n");
		strcpy(empty, SERVICE_FAIL_CODE_DECRYPT);
		emptyResult.data = empty; 
		return &emptyResult;	
	} else {
		getToken(clearString, SERVICE_TOKEN_ID_ENC_AUTH, token);
		stringToAuthCode(token, &authCode);
		getToken(clearString, SERVICE_TOKEN_ID_ENC_PARAM, param); 
   		printf("Decrypted message from client:\n%s\n", 
						clearString);
	}

	getToken(clearString, SERVICE_TOKEN_ID_ENC_LABEL, token);
        blk = findBlockFromLabel(token);  
	if (blk == NULL) {
		printf("Server cannot find the block corresponding "
					"to client's request\n");
		strcpy(empty, SERVICE_FAIL_CODE);
		emptyResult.data = empty; 
		return &emptyResult;
	}

	if (blk->state == STATE_WAIT_FOR_PAYMENT) {
        	error = pthread_create(&threadId, NULL, waitForPayment, 
						(void *) blk);
       	 	if (!error)
            		printf("\nThread creation successful\n");
		else
			printf("\nThread creation failed!\n");

		// Pause for waitForPayment() thread (throttles incoming reqs)
		sleep(1);
	}
  
	if (blk->state != STATE_PAYMENT_VERIFIED) {
		printf("Client cannot make service requests, "
					"before payment is verified!\n");
		strcpy(empty, SERVICE_FAIL_CODE);
		emptyResult.data = empty; 
		return &emptyResult;
	}

	// Verify that the authorization token is valid
	sequenceNum = (int) (authCode.saltPlusSequenceNumber & 
				INIT_AUTH_PROPER_MASK_2);
	printf("PPC sequenceNum = %d\n", sequenceNum);
	if ((authCode.baseCode != blk->authCode.baseCode) ||
			(sequenceNum < blk->minSeqAllowed) ||
			(sequenceNum > blk->maxSeqAllowed)) {
				printf("Client used invalid authorization "
						"code or sequence number.\n");
		strcpy(empty, SERVICE_FAIL_CODE);
		emptyResult.data = empty; 
		return &emptyResult;
	}

	blk->minSeqAllowed = sequenceNum + 1;

	// Service the call  (serviceType, param)
	// Encrypt the result with SessionKey before sending to the client

	result.data = result_text;
	printf("[11]::RPC: Server sent result of query: %s\n", result_text);

	return &result;
}
